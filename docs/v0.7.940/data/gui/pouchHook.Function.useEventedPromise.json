{"id":5071,"name":"useEventedPromise","kind":64,"kindString":"Function","flags":{},"children":[],"sources":[{"fileName":"src/gui/pouchHook.ts","fullFileName":"/home/brian/FAIMS/3/FAIMS3/src/gui/pouchHook.ts","line":226,"character":16,"url":"https://github.com/FAIMS/FAIMS3/blob/ea3e3d3f/src/gui/pouchHook.ts#L226"}],"signatures":[{"id":5072,"name":"useEventedPromise","kind":4096,"kindString":"Call signature","flags":{},"comment":{"summary":[{"kind":"text","text":"React hook abtracting the use of an EventEmitter combined with a Promise\n\nAllows you to wait for events to occur, then when they do occur, further\nwait for a Promise to resolve before give you a final value.\nIn the intermediate state, you can render something different.\n\nThis can also (because of PouchDB Change events) cause the promise to re-run\nwhenever an EventEmitter emits an event. (Attaching to this event emitter\nis left to the user. The user gets a callback to attach)"}],"blockTags":[{"tag":"@returns","content":[{"kind":"text","text":"Current state of the promise: Loading, Error, or Resolved, and\n         Function to manually trigger the Promise to re-run as if an event or\n         error occurred"}]}]},"typeParameter":[{"id":5073,"name":"A","kind":131072,"kindString":"Type parameter","flags":{},"type":{"type":"array","elementType":{"type":"intrinsic","name":"unknown"}}},{"id":5074,"name":"V","kind":131072,"kindString":"Type parameter","flags":{}}],"parameters":[{"id":5075,"name":"label","kind":32768,"kindString":"Parameter","flags":{},"type":{"type":"intrinsic","name":"string"},"text":{}},{"id":5076,"name":"startGetting","kind":32768,"kindString":"Parameter","flags":{},"comment":{"summary":[{"kind":"text","text":"Main promise that gets the value you want"}]},"type":{"type":"reflection","declaration":{"id":5077,"name":"__type","kind":65536,"kindString":"Type literal","flags":{},"sources":[{"fileName":"src/gui/pouchHook.ts","line":228,"character":16,"url":"https://github.com/FAIMS/FAIMS3/blob/ea3e3d3f/src/gui/pouchHook.ts#L228"}],"signatures":[{"id":5078,"name":"__type","kind":4096,"kindString":"Call signature","flags":{},"parameters":[{"id":5079,"name":"args","kind":32768,"kindString":"Parameter","flags":{"isRest":true},"type":{"type":"reference","id":5073,"name":"A"}}],"type":{"type":"reference","typeArguments":[{"type":"reference","id":5074,"name":"V"}],"name":"Promise","qualifiedName":"Promise","package":"typescript"}}]}},"text":{"comment":"<p>Main promise that gets the value you want</p>\n"}},{"id":5080,"name":"startListening","kind":32768,"kindString":"Parameter","flags":{},"comment":{"summary":[{"kind":"text","text":"Gives you a callback that you attach to an EventEmitter\n                      Also, if the user needs to detach this, this should return\n                      A 'destructor' to detach it (or if listener_dependencies changes)"}]},"type":{"type":"reflection","declaration":{"id":5081,"name":"__type","kind":65536,"kindString":"Type literal","flags":{},"sources":[{"fileName":"src/gui/pouchHook.ts","line":229,"character":18,"url":"https://github.com/FAIMS/FAIMS3/blob/ea3e3d3f/src/gui/pouchHook.ts#L229"}],"signatures":[{"id":5082,"name":"__type","kind":4096,"kindString":"Call signature","flags":{},"parameters":[{"id":5083,"name":"trigger_callback","kind":32768,"kindString":"Parameter","flags":{},"type":{"type":"reflection","declaration":{"id":5084,"name":"__type","kind":65536,"kindString":"Type literal","flags":{},"sources":[{"fileName":"src/gui/pouchHook.ts","line":230,"character":22,"url":"https://github.com/FAIMS/FAIMS3/blob/ea3e3d3f/src/gui/pouchHook.ts#L230"}],"signatures":[{"id":5085,"name":"__type","kind":4096,"kindString":"Call signature","flags":{},"parameters":[{"id":5086,"name":"args","kind":32768,"kindString":"Parameter","flags":{"isRest":true},"type":{"type":"intrinsic","name":"any"}}],"type":{"type":"intrinsic","name":"void"}}]}}},{"id":5087,"name":"error_callback","kind":32768,"kindString":"Parameter","flags":{},"type":{"type":"reflection","declaration":{"id":5088,"name":"__type","kind":65536,"kindString":"Type literal","flags":{},"sources":[{"fileName":"src/gui/pouchHook.ts","line":231,"character":20,"url":"https://github.com/FAIMS/FAIMS3/blob/ea3e3d3f/src/gui/pouchHook.ts#L231"}],"signatures":[{"id":5089,"name":"__type","kind":4096,"kindString":"Call signature","flags":{},"parameters":[{"id":5090,"name":"error","kind":32768,"kindString":"Parameter","flags":{},"type":{"type":"reflection","declaration":{"id":5091,"name":"__type","kind":65536,"kindString":"Type literal","flags":{}}}}],"type":{"type":"intrinsic","name":"void"}}]}}}],"type":{"type":"union","types":[{"type":"intrinsic","name":"void"},{"type":"reflection","declaration":{"id":5092,"name":"__type","kind":65536,"kindString":"Type literal","flags":{},"sources":[{"fileName":"src/gui/pouchHook.ts","line":232,"character":15,"url":"https://github.com/FAIMS/FAIMS3/blob/ea3e3d3f/src/gui/pouchHook.ts#L232"}],"signatures":[{"id":5093,"name":"__type","kind":4096,"kindString":"Call signature","flags":{},"type":{"type":"intrinsic","name":"void"}}]}}]}}]}},"text":{"comment":"<p>Gives you a callback that you attach to an EventEmitter\n                      Also, if the user needs to detach this, this should return\n                      A &#39;destructor&#39; to detach it (or if listener_dependencies changes)</p>\n"}},{"id":5094,"name":"stopAtError","kind":32768,"kindString":"Parameter","flags":{},"comment":{"summary":[{"kind":"text","text":"Determines behaviour of error handling:\n                   true: Whenever an error is thrown from the main promise OR\n                         from the startListening's error_callback, everything\n                         part of this hook stops, only returning the last error\n                   false: An error is treated like a regular value: If new events\n                          from the listener are triggered, or dependencies change,\n                          the error is discarded and the promise is re-run."}]},"type":{"type":"intrinsic","name":"boolean"},"text":{"comment":"<p>Determines behaviour of error handling:\n                   true: Whenever an error is thrown from the main promise OR\n                         from the startListening&#39;s error_callback, everything\n                         part of this hook stops, only returning the last error\n                   false: An error is treated like a regular value: If new events\n                          from the listener are triggered, or dependencies change,\n                          the error is discarded and the promise is re-run.</p>\n"}},{"id":5095,"name":"dependencies","kind":32768,"kindString":"Parameter","flags":{},"comment":{"summary":[{"kind":"text","text":"When values in this list change, the promise re-runs,\n                    and startListening re-runs, (The stored output of previous call\n                    to startListening, i.e. last destructor, is run as well)\n                    You'd usually use this if startListening listens on different things\n                    depending on some values, in which case, put said values in this array.\n                    Developer note: I had separate promise and startListening dependencies,\n                    But in practice they ended up being the same in most use cases,\n                    and if you've setup destructors properly, it doesn't hurt."}]},"type":{"type":"reference","name":"DependencyList","qualifiedName":"React.DependencyList","package":"@types/react"},"text":{"comment":"<p>When values in this list change, the promise re-runs,\n                    and startListening re-runs, (The stored output of previous call\n                    to startListening, i.e. last destructor, is run as well)\n                    You&#39;d usually use this if startListening listens on different things\n                    depending on some values, in which case, put said values in this array.\n                    Developer note: I had separate promise and startListening dependencies,\n                    But in practice they ended up being the same in most use cases,\n                    and if you&#39;ve setup destructors properly, it doesn&#39;t hurt.</p>\n"}},{"id":5096,"name":"args","kind":32768,"kindString":"Parameter","flags":{"isRest":true},"comment":{"summary":[{"kind":"text","text":"Arguments used to call startGetting for the first time, and\n            for any subsequent times where a dependency array changes"}]},"type":{"type":"reference","id":5073,"name":"A"},"text":{"comment":"<p>Arguments used to call startGetting for the first time, and\n            for any subsequent times where a dependency array changes</p>\n"}}],"type":{"type":"reference","id":5097,"typeArguments":[{"type":"reference","id":5074,"name":"V"},{"type":"reference","id":5073,"name":"A"}],"name":"PromiseState"},"is":{"declaration":false},"location":{"query":"gui/pouchHook.Function.useEventedPromise","hash":"useEventedPromise"},"text":{"comment":"<p>React hook abtracting the use of an EventEmitter combined with a Promise</p>\n<p>Allows you to wait for events to occur, then when they do occur, further\nwait for a Promise to resolve before give you a final value.\nIn the intermediate state, you can render something different.</p>\n<p>This can also (because of PouchDB Change events) cause the promise to re-run\nwhenever an EventEmitter emits an event. (Attaching to this event emitter\nis left to the user. The user gets a callback to attach)</p>\n<h5>Returns:</h5><p>Current state of the promise: Loading, Error, or Resolved, and\n         Function to manually trigger the Promise to re-run as if an event or\n         error occurred</p>\n"},"sources":[{"fileName":"src/gui/pouchHook.ts","fullFileName":"/home/brian/FAIMS/3/FAIMS3/src/gui/pouchHook.ts","line":226,"character":0,"url":"https://github.com/FAIMS/FAIMS3/blob/ea3e3d3f/src/gui/pouchHook.ts#L226"}],"parentId":5071}],"is":{"declaration":true},"location":{"query":"gui/pouchHook.Function.useEventedPromise","hash":""},"text":{},"parentId":4974}
