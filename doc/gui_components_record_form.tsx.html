

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> gui/components/record/form.tsx</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="RecordDraftState.html">RecordDraftState</a></li></ul><h3>Interfaces</h3><ul><li><a href="ProjectObject.html">ProjectObject</a></li><li><a href="ProjectRevisionListing.html">ProjectRevisionListing</a></li><li><a href="SplitRecordID.html">SplitRecordID</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ConnectionInfo_create_pouch">ConnectionInfo_create_pouch</a></li><li><a href="global.html#LoginButton">LoginButton</a></li><li><a href="global.html#THROTTLE_TIME">THROTTLE_TIME</a></li><li><a href="global.html#active_db">active_db</a></li><li><a href="global.html#all_meta_synced">all_meta_synced</a></li><li><a href="global.html#all_projects_updated">all_projects_updated</a></li><li><a href="global.html#constantArgs">constantArgs</a></li><li><a href="global.html#constantArgsShared">constantArgsShared</a></li><li><a href="global.html#constantArgsSplit">constantArgsSplit</a></li><li><a href="global.html#createdListings">createdListings</a></li><li><a href="global.html#createdProjects">createdProjects</a></li><li><a href="global.html#data_dbs">data_dbs</a></li><li><a href="global.html#default_changes_opts">default_changes_opts</a></li><li><a href="global.html#deleteStagedData">deleteStagedData</a></li><li><a href="global.html#directory_db">directory_db</a></li><li><a href="global.html#ensure_local_db">ensure_local_db</a></li><li><a href="global.html#ensure_synced_db">ensure_synced_db</a></li><li><a href="global.html#firstDefinedFromList">firstDefinedFromList</a></li><li><a href="global.html#getDataDB">getDataDB</a></li><li><a href="global.html#getProjectDB">getProjectDB</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#initialize_state">initialize_state</a></li><li><a href="global.html#listDraftMetadata">listDraftMetadata</a></li><li><a href="global.html#listDraftsEncoded">listDraftsEncoded</a></li><li><a href="global.html#listRecordMetadata">listRecordMetadata</a></li><li><a href="global.html#listenDataDB">listenDataDB</a></li><li><a href="global.html#listenProject">listenProject</a></li><li><a href="global.html#listenProjectDB">listenProjectDB</a></li><li><a href="global.html#listing_projects_synced">listing_projects_synced</a></li><li><a href="global.html#listings_updated">listings_updated</a></li><li><a href="global.html#local_auth_db">local_auth_db</a></li><li><a href="global.html#local_state_db">local_state_db</a></li><li><a href="global.html#metadata_dbs">metadata_dbs</a></li><li><a href="global.html#newStagedData">newStagedData</a></li><li><a href="global.html#process_listing">process_listing</a></li><li><a href="global.html#process_project">process_project</a></li><li><a href="global.html#projects_dbs">projects_dbs</a></li><li><a href="global.html#projects_meta_synced">projects_meta_synced</a></li><li><a href="global.html#reprocess_listing">reprocess_listing</a></li><li><a href="global.html#resolve_record_id">resolve_record_id</a></li><li><a href="global.html#setLocalConnection">setLocalConnection</a></li><li><a href="global.html#setStagedData">setStagedData</a></li><li><a href="global.html#update_listing">update_listing</a></li><li><a href="global.html#update_project">update_project</a></li><li><a href="global.html#useEventedPromise">useEventedPromise</a></li><li><a href="global.html#waitForStateOnce">waitForStateOnce</a></li></ul></div><div class="category"><h2>Database</h2><h3>Modules</h3><ul><li><a href="module-data_storage.html">data_storage</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>gui/components/record/form.tsx</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Copyright 2021, 2022 Macquarie University
 *
 * Licensed under the Apache License Version 2.0 (the, "License");
 * you may not use, this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing software
 * distributed under the License is distributed on an "AS IS" BASIS
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND either express or implied.
 * See, the License, for the specific language governing permissions and
 * limitations under the License.
 *
 * Filename: form.tsx
 * Description:
 *   Record/Draft form file
 */

import React from 'react';
import {withRouter} from 'react-router-dom';
import {RouteComponentProps} from 'react-router';
import {Formik, Form} from 'formik';

import {Grid, Box, Typography, Divider} from '@mui/material';

import {firstDefinedFromList} from './helpers';
import {
  get_logic_fields,
  get_logic_views,
  update_by_branching_logic,
} from './branchingLogic';

import {ViewComponent} from './view';

import {ActionType} from '../../../context/actions';

import * as ROUTES from '../../../constants/routes';
import {
  ProjectID,
  RecordID,
  RevisionID,
  Annotations,
  Relationship,
} from '../../../datamodel/core';
import {ProjectUIModel} from '../../../datamodel/ui';
import {upsertFAIMSData, getFullRecordData} from '../../../data_storage';
import {getValidationSchemaForViewset} from '../../../data_storage/validation';
import {store} from '../../../context/store';
import RecordDraftState from '../../../sync/draft-state';
import {
  getFieldsForViewSet,
  getFieldNamesFromFields,
  getReturnedTypesForViewSet,
} from '../../../uiSpecification';
import {DEBUG_APP} from '../../../buildconfig';
import {getCurrentUserId} from '../../../users';
import {Link} from '@mui/material';
import {Link as RouterLink} from 'react-router-dom';
import RecordStepper from './recordStepper';
import {savefieldpersistentSetting} from './fieldPersistentSetting';
import {get_fieldpersistentdata} from '../../../datamodel/fieldpersistent';

import {
  getParentlinkInfo,
  getParentInfo,
  getChildInfo,
  getParentLink_from_relationship,
} from './relationships/RelatedInformation';

import CircularLoading from '../ui/circular_loading';
import FormButtonGroup, {DevTool} from './formButton';
import UGCReport from './UGCReport';
import {generateFAIMSDataID, getFirstRecordHead} from '../../../data_storage';
import {logError} from '../../../logging';
type RecordFormProps = {
  project_id: ProjectID;
  record_id: RecordID;
  // Might be given in the URL:
  ui_specification: ProjectUIModel;
  conflictfields?: string[] | null;
  handleChangeTab?: Function;
  metaSection?: any;
  isSyncing?: string;
  disabled?: boolean;
  handleSetIsDraftSaving: Function;
  handleSetDraftLastSaved: Function;
  handleSetDraftError: Function;
  setRevision_id?: Function;
  ViewName?: string | null;
  draftLastSaved?: null | Date;
  mq_above_md?: boolean;
} &amp; (
  | {
      // When editing existing record, we require the caller to know its revision
      revision_id: RevisionID;
      // The user can view records without editing them, and to facilitate this,
      // having a draft id is optional.
      // In this mode, when the user starts editing, a draft ID is created and
      // stored as state on RecordForm.
      draft_id?: string;

      // To avoid 'type' in this.props, and since in JS when a key is not set,
      // you get back undefined:
      type?: undefined;
    }
  | {
      // When creating a new record,  revision is not yet created.
      // the user had to have already been prompted with viewset/type
      type: string;

      // Draft id, when creating a new record, is created by a redirect
      draft_id: string;

      // To avoid 'revision_id' in this.props, and since in JS when a key is not set,
      // you get back undefined:
      revision_id?: undefined;
    }
);

type RecordFormState = {
  // This is set by formChanged() function,
  type_cached: string | null;
  view_cached: string | null;
  activeStep: number;
  revision_cached: string | undefined;
  initialValues: {[fieldName: string]: unknown} | null;
  annotation: {[field_name: string]: Annotations};
  /**
   * Set only by newDraftListener, but this is only non-null
   * for a single render. In that render, a notification will pop up to the user
   * letting them redirect to the draft's URL
   */
  draft_created: string | null;
  description: string | null;
  ugc_comment: string | null;
  relationship: Relationship | null;
  fieldNames: string[];
  views: string[];
};

class RecordForm extends React.Component&lt;
  RecordFormProps &amp; RouteComponentProps,
  RecordFormState
> {
  draftState: RecordDraftState;

  // List of timeouts that unmount must cancel
  timeouts: typeof setTimeout[] = [];
  _isMounted = false;

  async componentDidUpdate(
    prevProps: RecordFormProps,
    prevState: RecordFormState
  ) {
    if (DEBUG_APP)
      console.debug(
        'initial set up ',
        prevProps.revision_id,
        this.state.revision_cached,
        this.props.revision_id
      );
    if (
      prevProps.project_id !== this.props.project_id ||
      // prevProps.record_id !== this.props.record_id ||
      (prevProps.revision_id !== this.props.revision_id &amp;&amp;
        this.state.revision_cached !== this.props.revision_id) ||
      prevProps.draft_id !== this.props.draft_id //add this to reload the form when user jump back to previous record
    ) {
      if (DEBUG_APP)
        console.debug(
          'initial set up update',
          prevProps.revision_id,
          this.state.revision_cached,
          this.props.revision_id
        );
      // Stop rendering immediately (i.e. go to loading screen immediately)
      this.setState({
        initialValues: null,
        type_cached: null,
        view_cached: null,
        activeStep: 0,
        revision_cached: undefined,
        annotation: {},
        description: null,
        relationship: {},
      });
      // Re-initialize basically everything.
      // if (this.props.revision_id !== undefined)
      this.formChanged(true, this.props.revision_id); // need to check if revision id been passed corrected: after conflict resolved, user save form and user open another form
    }
    // update the viewName if user click link
    if (this.props.ViewName !== this.state.view_cached) {
      if (
        this.props.ViewName !== null &amp;&amp;
        this.props.ViewName !== undefined &amp;&amp;
        this.state.type_cached !== null &amp;&amp;
        this.props.ui_specification.viewsets[
          this.state.type_cached
        ].views.includes(this.props.ViewName)
      )
        this.updateView(this.props.ViewName);
    }
    if (prevState.view_cached !== this.state.view_cached) {
      window.scrollTo(0, 200);
    }
  }

  constructor(props: RecordFormProps &amp; RouteComponentProps) {
    super(props);
    this.draftState = new RecordDraftState(this.props);
    this.state = {
      type_cached: this.props.type ?? null,
      view_cached: null,
      activeStep: 0,
      revision_cached: this.props.revision_id, // pass revision_id when form is opened, need to check if revision id been passed corrected
      initialValues: null,
      draft_created: null,
      annotation: {},
      description: null,
      ugc_comment: null,
      relationship: {},
      fieldNames: [],
      views: [],
    };
    this.setState = this.setState.bind(this);
    this.setInitialValues = this.setInitialValues.bind(this);
    this.updateannotation = this.updateannotation.bind(this);
    this.onChangeStepper = this.onChangeStepper.bind(this);
    this.onChangeTab = this.onChangeTab.bind(this);
  }

  componentDidMount() {
    // On mount, draftState.start() must be called, so give this false:
    this._isMounted = true;
    if (this._isMounted) {
      if (this.state.revision_cached !== null)
        this.formChanged(false, this.state.revision_cached);
      //need to check if revision id been passed corrected
      else this.formChanged(false, this.props.revision_id);
    }
  }

  newDraftListener(draft_id: string) {
    this.setState({draft_created: draft_id});
  }

  saveListener(val: boolean | {}) {
    if (val === true) {
      // Start saving
      this.props.handleSetIsDraftSaving(true);
    } else if (val === false) {
      // Finished saving successfully
      this.props.handleSetIsDraftSaving(false);
      this.props.handleSetDraftLastSaved(new Date());
    } else {
      // Error occurred while saving
      // Heuristically determine a nice user-facing error
      const error_message =
        (val as {message?: string}).message || val.toString();

      if (error_message === 'no changes') {
        //for existing record with no new draft created, set saving false and reset the last draft time
        this.props.handleSetIsDraftSaving(false);
        if (
          this.props.draftLastSaved === null ||
          this.props.draftLastSaved === undefined
        )
          this.props.handleSetDraftLastSaved(new Date());
      } else {
        if (DEBUG_APP) {
          console.log('saveListener', val);
        }

        this.props.handleSetIsDraftSaving(false);
        this.props.handleSetDraftError(error_message);
        this.context.dispatch({
          type: ActionType.ADD_ALERT,
          payload: {
            message: 'Could not load previous data: ' + error_message,
            severity: 'warnings',
          },
        });
      }
    }
  }

  async formChanged(
    draft_saving_started_already: boolean,
    passed_revision_id: string | undefined
  ) {
    let revision_id = passed_revision_id;
    if (DEBUG_APP) console.debug('check passed revision id', revision_id);
    if (revision_id === undefined) {
      try {
        // for new draft but saved record, get the revision instead of using the null
        const first_revision_id = await getFirstRecordHead(
          this.props.project_id,
          this.props.record_id
        );
        revision_id = first_revision_id;
        if (DEBUG_APP)
          console.debug('get record revision', this.props.record_id);
      } catch (error) {
        if (DEBUG_APP) console.debug('new record', this.props.record_id);
      }
    }
    // const revision_id = this.props.revision_id;
    try {
      let this_type;
      if (this.props.type === undefined) {
        if (revision_id !== undefined) {
          const latest_record = await getFullRecordData(
            this.props.project_id,
            this.props.record_id,
            revision_id
          );
          if (DEBUG_APP)
            console.debug(
              'record start initial',
              this.props.record_id,
              revision_id
            );
          if (latest_record === null) {
            this.props.handleSetDraftError(
              `Could not find data for record ${this.props.record_id}`
            );
            this.context.dispatch({
              type: ActionType.ADD_ALERT,
              payload: {
                message:
                  'Could not load existing record: ' + this.props.record_id,
                severity: 'warning',
              },
            });
            return;
          } else {
            this_type = latest_record.type;
          }
        } else {
          throw Error(`Viewset for type '${this_type}' is missing`);
        }
      } else {
        this_type = this.props.type;
      }

      if (!(this_type in this.props.ui_specification.viewsets)) {
        throw Error(`Viewset for type '${this_type}' is missing`);
      }

      if (!('views' in this.props.ui_specification.viewsets[this_type])) {
        throw Error(
          `Viewset for type '${this_type}' is missing 'views' property'`
        );
      }

      if (this.props.ui_specification.viewsets[this_type].views.length === 0) {
        throw Error(`Viewset for type '${this_type}' has no views`);
      }

      // this.get_view_description(this.props.ui_specification.viewsets[this_type].views[0])
      let viewName = this.props.ui_specification.viewsets[this_type].views[0];
      if (
        this.props.ViewName !== null &amp;&amp;
        this.props.ViewName !== undefined &amp;&amp;
        this.props.ui_specification.viewsets[this_type].views.includes(
          this.props.ViewName
        )
      ) {
        viewName = this.props.ViewName;
      } else if (
        this.state.view_cached !== null &amp;&amp;
        this.state.view_cached !== undefined &amp;&amp;
        this.props.ui_specification.viewsets[this_type].views.includes(
          this.state.view_cached
        )
      ) {
        viewName = this.state.view_cached;
      }
      await this.setState({
        type_cached: this_type,
        view_cached: viewName,
        revision_cached: revision_id,
      });
    } catch (err: any) {
      console.warn('setUISpec/setLastRev error', err);
      this.context.dispatch({
        type: ActionType.ADD_ALERT,
        payload: {
          message: `Project is not fully downloaded or not setup correctly (${err.toString()})`,
          severity: 'error',
        },
      });
      // This form cannot be shown at all. No recovery except go back to project.
      this.props.history.goBack();
      return;
    }
    try {
      // these come after setUISpec &amp; setLastRev has set view_name &amp; revision_id these to not null
      this.requireView();
      // If the draft saving has .start()'d already,
      // The proper way to change the record/revision/etc is this
      // (saveListener is already bound at this point)
      if (draft_saving_started_already) {
        this.draftState.recordChangeHook(this.props, {
          type: this.state.type_cached!,
          field_types: getReturnedTypesForViewSet(
            this.props.ui_specification,
            this.requireViewsetName()
          ),
        });
      } else {
        this.draftState.saveListener = this.saveListener.bind(this);
        this.draftState.newDraftListener = this.newDraftListener.bind(this);
        await this.draftState.start({
          type: this.state.type_cached!,
          field_types: getReturnedTypesForViewSet(
            this.props.ui_specification,
            this.requireViewsetName()
          ),
        });
      }
    } catch (err) {
      logError(err);
    }
    try {
      await this.setInitialValues(revision_id);
    } catch (err: any) {
      logError(err);
      this.context.dispatch({
        type: ActionType.ADD_ALERT,
        payload: {
          message: 'Could not load previous data: ' + err.message,
          severity: 'warnings',
        },
      });
      // Show an empty form
      this.setState({
        initialValues: {
          _id: this.props.record_id!,
          _project_id: this.props.project_id,
        },
      });
    }

    try {
      //save the child record when child record been pop
      if (DEBUG_APP)
        console.debug(
          'current revision ID after in formChanged initial',
          this.props.revision_id,
          this.state.revision_cached
        );
      if (
        this.props.revision_id === undefined &amp;&amp;
        this.state.revision_cached === undefined
      ) {
        const location: any = this.props.location;
        if (
          location !== undefined &amp;&amp;
          location.state !== undefined &amp;&amp;
          location.state !== null &amp;&amp;
          location.state.parent_record_id !== undefined &amp;&amp;
          location.state.parent_record_id !== this.props.record_id &amp;&amp;
          this.state.initialValues !== null
        ) {
          if (
            location.state.child_record_id !== undefined &amp;&amp;
            location.state.child_record_id !== this.props.record_id
          ) {
            //child_record_id should always be current record_id, otherwise there would be an issue
            if (DEBUG_APP) {
              console.debug(
                'child_record_id is not record_id  ',
                this.props.record_id,
                location.state.child_record_id
              );
            }
          } else
            this.save(this.state.initialValues, false, 'continue', () =>
              console.log('saved')
            );
        }
      }
    } catch (err: any) {
      logError(err);
    }
  }

  async componentWillUnmount() {
    await this.draftState.forceSave();
    //end of update values
    this._isMounted = false;
    for (const timeout_id of this.timeouts) {
      clearTimeout(timeout_id as unknown as Parameters&lt;typeof clearTimeout>[0]);
    }
    this.draftState.stop();
  }

  async setInitialValues(revision_id: string | undefined) {
    /***
     * Formik requires a single object for initialValues, collect these from the
     * (in order high priority to last resort): draft storage, database, ui schema
     */
    if (DEBUG_APP)
      console.debug('current revision id in Initial', this.props.revision_id);
    const fromdb: any =
      revision_id === undefined
        ? {}
        : (await getFullRecordData(
            this.props.project_id,
            this.props.record_id,
            revision_id
          )) || {};
    const database_data = fromdb.data ?? {};
    const database_annotations = fromdb.annotations ?? {};

    const [staged_data, staged_annotations] =
      await this.draftState.getInitialValues();
    if (DEBUG_APP) {
      console.debug('Staged values', staged_data, staged_annotations);
    }

    const fields = getFieldsForViewSet(
      this.props.ui_specification,
      this.requireViewsetName()
    );
    const fieldNames = getFieldNamesFromFields(fields);

    // get value from persistent
    let persistentvalue: any = {};
    if (this.state.type_cached !== null)
      persistentvalue = await get_fieldpersistentdata(
        this.props.project_id,
        this.state.type_cached
      );

    const initialValues: {[key: string]: any} = {
      _id: this.props.record_id!,
      _project_id: this.props.project_id,
      _current_revision_id: revision_id,
    };
    const annotations: {[key: string]: any} = {};

    fieldNames.forEach(fieldName => {
      let initial_value = fields[fieldName]['initialValue'];
      // set value from persistence
      if (
        persistentvalue.data !== undefined &amp;&amp;
        persistentvalue.data[fieldName] !== undefined
      )
        initial_value = persistentvalue.data[fieldName];

      initialValues[fieldName] = firstDefinedFromList([
        staged_data[fieldName],
        database_data[fieldName],
        initial_value,
      ]);
      // set annotation from persistence
      let annotation_value = {annotation: '', uncertainty: false};

      if (
        persistentvalue.annotations !== undefined &amp;&amp;
        persistentvalue.annotations[fieldName] !== undefined
      )
        annotation_value = persistentvalue.annotations[fieldName];
      annotations[fieldName] = firstDefinedFromList([
        staged_annotations[fieldName],
        database_annotations[fieldName],
        annotation_value,
      ]);
    });

    // save child/link information into the parent/linked record when back to upper level
    const {field_id, new_record, is_related} = getChildInfo(
      this.props.location.state,
      this.props.project_id
    );

    if (is_related &amp;&amp; new_record !== null) {
      if (
        this.props.ui_specification['fields'][field_id]['component-parameters'][
          'multiple'
        ]
      ) {
        let isincluded = false;
        initialValues[field_id].map((r: any) => {
          if (r.record_id === new_record.record_id) {
            isincluded = true;
          }
        });

        if (isincluded === false) {
          initialValues[field_id].push(new_record);
        }
      } else {
        initialValues[field_id] = new_record;
      }
    }
    const related: Relationship = {};
    let parent = null;
    if (
      this.draftState.data.state !== 'uninitialized' &amp;&amp;
      this.draftState.data.relationship !== undefined
    )
      parent = fromdb.relationship?.parent;
    if (
      parent !== null &amp;&amp;
      parent !== undefined &amp;&amp;
      parent.record_id !== undefined
    )
      related['parent'] = parent;

    let linked = null;
    if (
      this.draftState.data.state !== 'uninitialized' &amp;&amp;
      this.draftState.data.relationship !== undefined
    )
      linked = fromdb.relationship?.linked;
    if (linked !== null &amp;&amp; linked !== undefined &amp;&amp; linked.length > 0)
      related['linked'] = linked;

    const relationship = getParentInfo(
      this.props.location.state,
      related,
      this.props.record_id
    );
    initialValues['fieldNames'] = [];
    initialValues['views'] = [];
    this.setState({
      initialValues: initialValues,
      annotation: annotations,
      relationship: fromdb.relationship ?? relationship,
    });
    if (DEBUG_APP) console.debug('current revision id', initialValues);
  }

  /**
   * Equivalent to setTimeout, but with added function that
   * clears any timeouts when the component is unmounted.
   * @param callback Function to run when timeout elapses
   */
  setTimeout(callback: () => void, time: number) {
    const my_index = this.timeouts.length;
    setTimeout(() => {
      try {
        callback();
        this.timeouts.splice(my_index, 1);
      } catch (err) {
        this.timeouts.splice(my_index, 1);
        throw err;
      }
    }, time);
  }

  requireView(): string {
    if (this.state.view_cached === null) {
      throw Error('The view name has not been determined yet');
    }
    return this.state.view_cached;
  }

  requireViewsetName(): string {
    if (this.state.type_cached === null) {
      throw Error('The viewset name has not been determined yet');
    }
    return this.state.type_cached;
  }

  requireInitialValues() {
    if (this.state.initialValues === null) {
      throw Error('The initial values have not been determined yet');
    }
    return this.state.initialValues;
  }

  requireDescription(viewName: string) {
    if (viewName === null || this.props.metaSection === null) {
      console.warn('The description has not been determined yet');
      return '';
    }
    if (DEBUG_APP) {
      console.log('+++++++++++' + viewName);
      console.log(this.props.metaSection);
    }
    if (
      viewName !== null &amp;&amp;
      this.props.metaSection !== undefined &amp;&amp;
      this.props.metaSection[viewName] !== undefined &amp;&amp;
      this.props.metaSection[viewName]['sectiondescription' + viewName] !==
        undefined
    )
      return this.props.metaSection[viewName]['sectiondescription' + viewName];
    return '';
  }

  filterValues(values: object) {
    const new_values: any = {};
    for (const [k, v] of Object.entries(values)) {
      if (k !== '_id' &amp;&amp; k !== '_project_id' &amp;&amp; k !== '_current_revision_id') {
        new_values[k] = v;
        if (k[0] === '_') {
          logError(`Including possibly bad key ${k} in record`);
        }
      }
    }
    return new_values;
  }

  onChangeStepper(view_name: string, activeStepIndex: number) {
    this.setState({
      view_cached: view_name,
      activeStep: activeStepIndex,
    });
  }

  onChangeTab(event: React.ChangeEvent&lt;{}>, newValue: string) {
    const activeStepIndex = parseInt(newValue);
    console.log(activeStepIndex);

    if (this.state.type_cached !== null) {
      console.log(
        this.props.ui_specification.viewsets[this.state.type_cached].views[
          activeStepIndex
        ]
      );
      const viewname =
        this.props.ui_specification.viewsets[this.state.type_cached].views[
          activeStepIndex
        ];
      this.setState({
        view_cached: viewname,
        activeStep: activeStepIndex,
      });
    }
  }
  // before save:
  // for link/create new record
  // save child and parent information into record
  // function save:
  // - save doc/record
  // - save persistence data
  // - get new revision id, and set new revision id if user click save and continue
  // - clear the draft
  // after save: direct user to different path
  // - - publish and continue: setSubmitting re-enabled, so user can save form for the new revision id
  // - - publish and close: - close the current record and return to project list
  //                     - close the current record and back to parent record if record created from parent or if record has parent
  // - - publish and new:  - close the current record and create new record when current record has no parent relationship
  //                    - when current record has parent: close current record, add new record into parent record, open the new record with parent

  save(
    values: object,
    is_final_view: boolean,
    is_close: string,
    setSubmitting: any
  ) {
    const ui_specification = this.props.ui_specification;
    const viewsetName = this.requireViewsetName();
    //save state into persistent data
    savefieldpersistentSetting(
      this.props.project_id,
      this.state.type_cached,
      values,
      this.state.annotation,
      ui_specification
    );
    if (DEBUG_APP)
      console.debug(
        'current revision id',
        this.state.revision_cached,
        this.props.revision_id
      );
    return (
      getCurrentUserId(this.props.project_id)
        .then(userid => {
          const now = new Date();
          const doc = {
            record_id: this.props.record_id,
            revision_id: this.state.revision_cached ?? null,
            type: this.state.type_cached!,
            data: this.filterValues(values),
            updated_by: userid,
            updated: now,
            annotations: this.state.annotation ?? {},
            field_types: getReturnedTypesForViewSet(
              ui_specification,
              viewsetName
            ),
            ugc_comment: this.state.ugc_comment || '',
            relationship: this.state.relationship ?? {},
            deleted: false,
          };
          if (DEBUG_APP) {
            console.debug(
              'doc',
              this.props.record_id,
              this.state.revision_cached,
              this.props.location.state,
              this.state,
              doc
            );
          }
          return doc;
        })
        .then(doc => {
          return upsertFAIMSData(this.props.project_id, doc).then(
            revision_id => {
              // add to save the information for relationship when form saved,  TODO: need to be defined if it's saved when form been save
              try {
                if (DEBUG_APP)
                  console.debug('get new revision id++++' + revision_id);
                this.setState({revision_cached: revision_id});
                this.formChanged(true, revision_id);
                if (this.props.setRevision_id !== undefined)
                  this.props.setRevision_id(revision_id); //pass the revision id back
              } catch (error) {
                logError(error);
              }
              return is_close === 'close'
                ? doc.data['hrid' + this.state.type_cached] ??
                    this.props.record_id
                : revision_id; // return revision id for save and continue function
            }
          );
        })
        .then(result => {
          if (DEBUG_APP) {
            console.log(result);
          }
          const message = 'Record successfully saved';
          this.context.dispatch({
            type: ActionType.ADD_ALERT,
            payload: {
              message: message,
              severity: 'success',
            },
          });
          console.log('Saved record', result);
          return result;
        })
        .catch(err => {
          const message = 'Could not save record';
          this.context.dispatch({
            type: ActionType.ADD_ALERT,
            payload: {
              message: message,
              severity: 'error',
            },
          });
          logError(err);
        })
        //Clear the current draft area (Possibly after redirecting back to project page)
        .then(result => {
          return this.draftState.clear().then(() => {
            return result;
          });
        })
        .then(result => {
          //when user try to close the page
          if (is_close === 'continue') {
            setSubmitting(false);
            return result;
          } else {
            const RelationState = this.props.location.state;
            if (DEBUG_APP) console.debug('Location ', RelationState);
            if (RelationState !== undefined &amp;&amp; RelationState !== null) {
              const {state_parent, is_direct} = getParentlinkInfo(
                result,
                this.props.location.state,
                this.props.record_id
              );
              if (is_direct === false) {
                if (is_close === 'close') {
                  this.props.history.push(
                    ROUTES.NOTEBOOK + this.props.project_id
                  ); //update for save and close button
                  window.scrollTo(0, 0);
                  return result;
                } else if (is_close === 'new') {
                  //not child record
                  setSubmitting(false);
                  this.props.history.push(
                    ROUTES.NOTEBOOK +
                      this.props.project_id +
                      ROUTES.RECORD_CREATE +
                      this.state.type_cached
                  );
                  window.scrollTo(0, 0);
                  return result;
                }
              } else {
                if (is_close === 'close') {
                  this.props.history.push({
                    pathname: ROUTES.NOTEBOOK + state_parent.parent_link,
                    state: state_parent,
                  });
                  window.scrollTo(0, 0);
                  return result;
                } else if (is_close === 'new') {
                  // for new child record, should save the parent record and pass the location state --TODO
                  const LocationState: any = this.props.location.state;
                  setSubmitting(false);
                  this.props.history.push({
                    pathname:
                      ROUTES.NOTEBOOK +
                      this.props.project_id +
                      ROUTES.RECORD_CREATE +
                      this.state.type_cached,
                    state: this.props.location.state,
                  });
                  console.debug('current state', this.state);
                  const field_id = LocationState.field_id;
                  const new_record_id = generateFAIMSDataID();
                  const new_child_record = {
                    record_id: new_record_id,
                    project_id: this.props.project_id,
                  };
                  getFirstRecordHead(
                    this.props.project_id,
                    LocationState.parent_record_id
                  ).then(revision_id =>
                    getFullRecordData(
                      this.props.project_id,
                      LocationState.parent_record_id,
                      revision_id
                    ).then(latest_record => {
                      const new_doc = latest_record;
                      if (new_doc !== null) {
                        if (
                          this.props.ui_specification['fields'][field_id][
                            'component-parameters'
                          ]['multiple'] === true
                        )
                          new_doc['data'][field_id] = [
                            ...new_doc['data'][field_id],
                            new_child_record,
                          ];
                        else
                          new_doc['data'][field_id] = [
                            ...new_doc['data'][field_id],
                            new_child_record,
                          ];
                        upsertFAIMSData(this.props.project_id, new_doc)
                          .then(new_revision_id => {
                            const location_state: any = LocationState;
                            location_state['parent_link'] =
                              ROUTES.getRecordRoute(
                                this.props.project_id,
                                (
                                  location_state.parent_record_id || ''
                                ).toString(),
                                (new_revision_id || '').toString()
                              ).replace('/notebooks/', '');
                            location_state['child_record_id'] = new_record_id;
                            if (DEBUG_APP)
                              console.debug('new child state', location_state);
                            this.props.history.push({
                              pathname:
                                ROUTES.NOTEBOOK +
                                this.props.project_id +
                                ROUTES.RECORD_CREATE +
                                this.state.type_cached,
                              state: location_state,
                            });
                            setSubmitting(false);
                            window.scrollTo(0, 0);
                            return result;
                          })
                          .catch(error => logError(error));
                      } else {
                        logError(
                          'Error saving the parent record, latest record is null'
                        );
                        this.props.history.push({
                          pathname:
                            ROUTES.NOTEBOOK +
                            this.props.project_id +
                            ROUTES.RECORD_CREATE +
                            this.state.type_cached,
                          state: LocationState.location_state,
                        });
                        setSubmitting(false);
                        window.scrollTo(0, 0);
                        return result;
                      }
                    })
                  );
                  return result;
                }
              }
            } else {
              const relationship = this.state.relationship;
              if (DEBUG_APP) console.debug('location state', relationship);
              if (
                relationship === undefined ||
                relationship === null ||
                relationship.parent === undefined ||
                relationship.parent === null
              ) {
                if (is_close === 'close') {
                  this.props.history.push(
                    ROUTES.NOTEBOOK + this.props.project_id
                  );
                  window.scrollTo(0, 0);
                  return result;
                } else if (is_close === 'new') {
                  //not child record
                  setSubmitting(false);
                  this.props.history.push(
                    ROUTES.NOTEBOOK +
                      this.props.project_id +
                      ROUTES.RECORD_CREATE +
                      this.state.type_cached
                  );
                  return result;
                }
              } else {
                getParentLink_from_relationship(
                  result,
                  relationship,
                  this.props.record_id,
                  this.props.project_id
                )
                  .then(LocationState => {
                    if (is_close === 'close') {
                      this.props.history.push({
                        pathname: LocationState.location_state.parent_link,
                      });
                      window.scrollTo(0, 0);
                      return result;
                    } else if (is_close === 'new') {
                      // for new child record, should save the parent record and pass the location state --TODO
                      // update parent information
                      const new_doc = LocationState.latest_record;
                      const field_id = LocationState.location_state.field_id;
                      const new_record_id = generateFAIMSDataID();
                      const new_child_record = {
                        record_id: new_record_id,
                        project_id: this.props.project_id,
                        // record_label:new_record_id
                        // relation_type_vocabPair: [],
                      };
                      if (new_doc !== null) {
                        if (
                          this.props.ui_specification['fields'][field_id][
                            'component-parameters'
                          ]['multiple'] === true
                        )
                          new_doc['data'][field_id] = [
                            ...new_doc['data'][field_id],
                            new_child_record,
                          ];
                        else
                          new_doc['data'][field_id] = [
                            ...new_doc['data'][field_id],
                            new_child_record,
                          ];
                        upsertFAIMSData(this.props.project_id, new_doc)
                          .then(new_revision_id => {
                            const location_state: any =
                              LocationState.location_state;
                            location_state['parent_link'] =
                              ROUTES.getRecordRoute(
                                this.props.project_id,
                                (
                                  location_state.parent_record_id || ''
                                ).toString(),
                                (new_revision_id || '').toString()
                              ).replace('/notebooks/', '');
                            location_state['child_record_id'] = new_record_id;
                            console.debug('new child state', location_state);
                            this.props.history.push({
                              pathname:
                                ROUTES.NOTEBOOK +
                                this.props.project_id +
                                ROUTES.RECORD_CREATE +
                                this.state.type_cached,
                              state: location_state,
                            });
                            setSubmitting(false);
                            window.scrollTo(0, 0);
                            return result;
                          })
                          .catch(error => logError(error));
                      } else {
                        logError(
                          'Error to save the parent record from child relationship, latest record is null'
                        );
                        this.props.history.push({
                          pathname:
                            ROUTES.NOTEBOOK +
                            this.props.project_id +
                            ROUTES.RECORD_CREATE +
                            this.state.type_cached,
                          state: LocationState.location_state,
                        });
                        setSubmitting(false);
                        window.scrollTo(0, 0);
                      }
                    }
                  })
                  .catch(error => logError(error));
              }
            }
          }
        })
    );
  }

  updateView(viewName: string) {
    if (viewName in this.props.ui_specification['views']) {
      this.setState({view_cached: viewName});
      this.forceUpdate();
      // Probably not needed, but we *know* we need to rerender when this
      // changes, so let's be explicit.
    } else {
      throw Error(`No view ${viewName}`);
    }
  }

  isReady(): boolean {
    if (DEBUG_APP)
      console.debug(
        'Initial',
        this.state.type_cached,
        this.state.initialValues,
        this.props.ui_specification,
        this.state.view_cached
      );
    return (
      this.state.type_cached !== null &amp;&amp;
      this.state.initialValues !== null &amp;&amp;
      this.props.ui_specification !== null &amp;&amp;
      this.state.view_cached !== null
    );
  }

  updateannotation(name: string, value: any, type: string) {
    const annotation = this.state.annotation ?? {};
    if (annotation !== undefined) {
      if (annotation[name] !== undefined) annotation[name][type] = value;
      else {
        annotation[name] = {annotation: '', uncertainty: false};
        annotation[name][type] = value;
      }
    } else {
      if (DEBUG_APP) {
        console.log(name + value);
      }
    }
    this.setState({...this.state, annotation: annotation});
  }

  render() {
    if (this.state.draft_created !== null) {
      // If a draft was created, that implies this form started from
      // a non draft, so it must have been an existing record (see props
      // as it's got a type {existing record} | {draft already created}
      this.context.dispatch({
        type: ActionType.ADD_CUSTOM_ALERT,
        payload: {
          severity: 'success',
          element: (
            &lt;React.Fragment>
              &lt;Link
                component={RouterLink}
                to={
                  ROUTES.NOTEBOOK +
                  this.props.project_id +
                  ROUTES.RECORD_EXISTING +
                  this.props.record_id! +
                  ROUTES.REVISION +
                  this.props.revision_id! +
                  ROUTES.RECORD_DRAFT +
                  this.state.draft_created
                }
              >
                Created new draft
              &lt;/Link>
            &lt;/React.Fragment>
          ),
        },
      });
      this.setState({draft_created: null});
    }

    if (this.isReady()) {
      const viewName = this.requireView();
      const viewsetName = this.requireViewsetName();
      const initialValues = this.requireInitialValues();
      const ui_specification = this.props.ui_specification;
      //fields list and views list could be updated depends on values user choose
      let fieldNames = get_logic_fields(
        this.props.ui_specification,
        initialValues,
        viewName
      );
      let views = get_logic_views(
        this.props.ui_specification,
        viewsetName,
        initialValues
      );
      const validationSchema = getValidationSchemaForViewset(
        ui_specification,
        viewsetName
      );
      //value could be update for branching logic, change to let
      let view_index = views.indexOf(viewName);
      let is_final_view = view_index + 1 === views.length;
      // this expression checks if we have the last element in the viewset array
      const description = this.requireDescription(viewName);
      // console.debug(
      //   'check current revision id',
      //   this.props.revision_id,
      //   this.state.revision_cached
      // );
      console.debug(
        'check current revision id draft',
        this.props.draft_id,
        this.state.draft_created,
        this.draftState
      );
      return (
        &lt;Box>
          {/* {this.state.revision_cached} */}
          {/* remove the tab for edit ---Jira 530 */}
          {/* add padding for form only */}
          &lt;div>
            &lt;Formik
              // enableReinitialize
              initialValues={initialValues}
              validationSchema={validationSchema}
              validateOnMount={true}
              validateOnChange={false}
              validateOnBlur={true}
              onSubmit={(values, {setSubmitting}) => {
                setSubmitting(true);
                return this.save(
                  values,
                  is_final_view,
                  'continue',
                  setSubmitting
                ).then(result => {
                  return result;
                });
              }}
            >
              {formProps => {
                //ONLY update if the updated field is the controller field
                fieldNames = update_by_branching_logic(
                  this.props.ui_specification,
                  formProps.values,
                  true,
                  fieldNames,
                  views,
                  viewName,
                  viewsetName,
                  formProps.touched
                );
                views = update_by_branching_logic(
                  this.props.ui_specification,
                  formProps.values,
                  false,
                  fieldNames,
                  views,
                  viewName,
                  viewsetName,
                  formProps.touched
                );
                view_index = views.indexOf(viewName);
                is_final_view = view_index + 1 === views.length;
                this.draftState.renderHook(
                  formProps.values,
                  this.state.annotation,
                  this.state.relationship ?? {}
                );
                return (
                  &lt;Form>
                    {views.length > 1 &amp;&amp; (
                      &lt;RecordStepper
                        view_index={view_index}
                        ui_specification={ui_specification}
                        onChangeStepper={this.onChangeStepper}
                        views={views}
                      />
                    )}

                    {description !== '' &amp;&amp; (
                      &lt;Box
                        bgcolor={'#fafafa'}
                        p={3}
                        style={{border: '1px #eeeeee dashed'}}
                      >
                        &lt;Typography>{description}&lt;/Typography>
                      &lt;/Box>
                    )}
                    &lt;br />

                    &lt;Grid container spacing={2}>
                      &lt;Grid item sm={12} xs={12}>
                        &lt;ViewComponent
                          viewName={viewName}
                          ui_specification={ui_specification}
                          formProps={formProps}
                          draftState={this.draftState}
                          annotation={this.state.annotation}
                          handerannoattion={this.updateannotation}
                          isSyncing={this.props.isSyncing}
                          conflictfields={this.props.conflictfields}
                          handleChangeTab={this.props.handleChangeTab}
                          fieldNames={fieldNames}
                          disabled={this.props.disabled}
                        />
                      &lt;/Grid>
                      &lt;br />
                      &lt;FormButtonGroup
                        is_final_view={is_final_view}
                        disabled={this.props.disabled}
                        onChangeStepper={this.onChangeStepper}
                        viewName={viewName}
                        view_index={view_index}
                        formProps={formProps}
                        ui_specification={ui_specification}
                        views={views}
                        mq_above_md={this.props.mq_above_md}
                        handleFormSubmit={(is_close: string) => {
                          formProps.setSubmitting(true);
                          this.setTimeout(() => {
                            this.save(
                              formProps.values,
                              is_final_view,
                              is_close,
                              formProps.setSubmitting
                            );
                          }, 500);
                        }}
                      />
                    &lt;/Grid>
                    {/* {UGCReport ONLY for the saved record} */}
                    {this.state.revision_cached !== undefined &amp;&amp; (
                      &lt;Box mt={3}>
                        &lt;Divider />
                        &lt;UGCReport
                          handleUGCReport={(value: string) => {
                            this.setState({ugc_comment: value});
                            this.save(
                              formProps.values,
                              is_final_view,
                              'continue',
                              formProps.setSubmitting
                            );
                          }}
                        />
                      &lt;/Box>
                    )}
                    &lt;DevTool formProps={formProps} state={this.state} />
                  &lt;/Form>
                );
              }}
            &lt;/Formik>
          &lt;/div>
        &lt;/Box>
      );
    } else {
      return (
        &lt;Box sx={{m: 1}}>
          &lt;CircularLoading label={'Loading record data'} />
        &lt;/Box>
      );
    }
  }
}
RecordForm.contextType = store;
export default withRouter(RecordForm);
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.0</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>


</body>
</html>
