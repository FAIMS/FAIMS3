

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> data_storage/index.ts</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="RecordDraftState.html">RecordDraftState</a></li></ul><h3>Interfaces</h3><ul><li><a href="ProjectObject.html">ProjectObject</a></li><li><a href="ProjectRevisionListing.html">ProjectRevisionListing</a></li><li><a href="SplitRecordID.html">SplitRecordID</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ConnectionInfo_create_pouch">ConnectionInfo_create_pouch</a></li><li><a href="global.html#LoginButton">LoginButton</a></li><li><a href="global.html#THROTTLE_TIME">THROTTLE_TIME</a></li><li><a href="global.html#active_db">active_db</a></li><li><a href="global.html#all_meta_synced">all_meta_synced</a></li><li><a href="global.html#all_projects_updated">all_projects_updated</a></li><li><a href="global.html#constantArgs">constantArgs</a></li><li><a href="global.html#constantArgsShared">constantArgsShared</a></li><li><a href="global.html#constantArgsSplit">constantArgsSplit</a></li><li><a href="global.html#createdListings">createdListings</a></li><li><a href="global.html#createdProjects">createdProjects</a></li><li><a href="global.html#data_dbs">data_dbs</a></li><li><a href="global.html#default_changes_opts">default_changes_opts</a></li><li><a href="global.html#deleteStagedData">deleteStagedData</a></li><li><a href="global.html#directory_db">directory_db</a></li><li><a href="global.html#ensure_local_db">ensure_local_db</a></li><li><a href="global.html#ensure_synced_db">ensure_synced_db</a></li><li><a href="global.html#firstDefinedFromList">firstDefinedFromList</a></li><li><a href="global.html#getDataDB">getDataDB</a></li><li><a href="global.html#getProjectDB">getProjectDB</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#initialize_state">initialize_state</a></li><li><a href="global.html#listDraftMetadata">listDraftMetadata</a></li><li><a href="global.html#listDraftsEncoded">listDraftsEncoded</a></li><li><a href="global.html#listRecordMetadata">listRecordMetadata</a></li><li><a href="global.html#listenDataDB">listenDataDB</a></li><li><a href="global.html#listenProject">listenProject</a></li><li><a href="global.html#listenProjectDB">listenProjectDB</a></li><li><a href="global.html#listing_projects_synced">listing_projects_synced</a></li><li><a href="global.html#listings_updated">listings_updated</a></li><li><a href="global.html#local_auth_db">local_auth_db</a></li><li><a href="global.html#local_state_db">local_state_db</a></li><li><a href="global.html#metadata_dbs">metadata_dbs</a></li><li><a href="global.html#newStagedData">newStagedData</a></li><li><a href="global.html#process_listing">process_listing</a></li><li><a href="global.html#process_project">process_project</a></li><li><a href="global.html#projects_dbs">projects_dbs</a></li><li><a href="global.html#projects_meta_synced">projects_meta_synced</a></li><li><a href="global.html#reprocess_listing">reprocess_listing</a></li><li><a href="global.html#resolve_record_id">resolve_record_id</a></li><li><a href="global.html#setLocalConnection">setLocalConnection</a></li><li><a href="global.html#setStagedData">setStagedData</a></li><li><a href="global.html#update_listing">update_listing</a></li><li><a href="global.html#update_project">update_project</a></li><li><a href="global.html#useEventedPromise">useEventedPromise</a></li><li><a href="global.html#waitForStateOnce">waitForStateOnce</a></li></ul></div><div class="category"><h2>Database</h2><h3>Modules</h3><ul><li><a href="module-data_storage.html">data_storage</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>data_storage/index.ts</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * Copyright 2021, 2022 Macquarie University
 *
 * Licensed under the Apache License Version 2.0 (the, "License");
 * you may not use, this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing software
 * distributed under the License is distributed on an "AS IS" BASIS
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND either express or implied.
 * See, the License, for the specific language governing permissions and
 * limitations under the License.
 *
 * Filename: index.ts
 * Description:
 *   API for accessing data from the GUI. The GUI should not use internals.ts,
 *   instead wrapper functions should be provided here.
 */

/**
 * The Data Storage module provides an API for accessing data from the GUI.
 * @module data_storage
 * @category Database
 */

import {v4 as uuidv4} from 'uuid';

import {DEBUG_APP} from '../buildconfig';
import {getDataDB} from '../sync';
import {
  RecordID,
  ProjectID,
  RevisionID,
  FAIMSTypeName,
  DEFAULT_REALTION_LINK_VOCAB,
} from '../datamodel/core';
import {Revision} from '../datamodel/database';
import {Record, RecordMetadata, RecordReference} from '../datamodel/ui';
import {shouldDisplayRecord} from '../users';
import {
  addNewRevisionFromForm,
  createNewRecord,
  generateFAIMSRevisionID,
  getRecord,
  getRevision,
  getFormDataFromRevision,
  updateHeads,
  getHRID,
  listRecordMetadata,
} from './internals';
import {getAllRecordsOfType, getAllRecordsWithRegex} from './queries';
import {logError} from '../logging';

/**
 * Project Revision Listing
 * @interface
 */
export interface ProjectRevisionListing {
  [_id: string]: string[];
}

export type RecordRevisionListing = RevisionID[];

export function generateFAIMSDataID(): RecordID {
  return 'rec-' + uuidv4();
}

/**
 * Get the revision id of the most recent revision of a record
 * @param project_id project identifier
 * @param record_id record identifier
 * @returns a promise resolving to a revisionid for the record
 */
export async function getFirstRecordHead(
  project_id: ProjectID,
  record_id: RecordID
): Promise&lt;RevisionID> {
  const record = await getRecord(project_id, record_id);
  return record.heads[0];
}

/**
 * Either create a new record or update an existing one
 * @param project_id project identifier
 * @param record new or existing record
 * @returns a promise resolving to the revision id of the new or updated record
 */
export async function upsertFAIMSData(
  project_id: ProjectID,
  record: Record
): Promise&lt;RevisionID> {
  if (record.record_id === undefined) {
    throw Error('record_id required to save record');
  }
  const revision_id = generateFAIMSRevisionID();
  if (record.revision_id === null) {
    if (DEBUG_APP) {
      console.info('New record', record);
    }
    await createNewRecord(project_id, record, revision_id);
    await addNewRevisionFromForm(project_id, record, revision_id);
  } else {
    if (DEBUG_APP) {
      console.info('Update existing record', record);
    }
    await addNewRevisionFromForm(project_id, record, revision_id);
    await updateHeads(
      project_id,
      record.record_id,
      [record.revision_id],
      revision_id
    );
  }
  return revision_id;
}

/**
 * Get the full record data for a given revision of a record
 * @param {ProjectID} project_id  Project identifier
 * @param {RecordID} record_id Record identifier
 * @param {RevisionID} revision_id Revision identifier
 * @param {boolean} is_deleted if true (default), return null if the revision has been deleted. If false, return the record even if deleted
 * @returns A promise that resolves to the requested record or null
 */
export async function getFullRecordData(
  project_id: ProjectID,
  record_id: RecordID,
  revision_id: RevisionID,
  is_deleted = true //default value should be true
): Promise&lt;Record | null> {
  const revision = await getRevision(project_id, revision_id);
  if (revision.deleted === true &amp;&amp; is_deleted) {
    // return null when is_deleted is not set or set as true
    return null;
  }
  const record = await getRecord(project_id, record_id);
  const form_data = await getFormDataFromRevision(project_id, revision);

  return {
    project_id: project_id,
    record_id: record_id,
    revision_id: revision_id,
    type: revision.type,
    data: form_data.data,
    updated_by: revision.created_by,
    updated: new Date(revision.created),
    created: new Date(record.created),
    created_by: record.created_by,
    annotations: form_data.annotations,
    field_types: form_data.types,
    relationship: revision.relationship,
    deleted: revision.deleted ?? false,
  };
}

/**
 * Get a list of revisions for a given record
 * @param {ProjectID} project_id
 * @param {RecordID} record_id
 * @returns {Promise&lt;RecordRevisionListing>} A promise resolving to a revision listing
 */
export async function listFAIMSRecordRevisions(
  project_id: ProjectID,
  record_id: RecordID
): Promise&lt;RecordRevisionListing> {
  try {
    const record = await getRecord(project_id, record_id);
    return record.revisions;
  } catch (err) {
    console.warn('failed to list data for id', record_id);
    throw err;
  }
}

/**
 * Get a list of revisions for a given project
 * @param {ProjectID} project_id
 * @returns {Promise&lt;ProjectRevisionListing>}
 */
export async function listFAIMSProjectRevisions(
  project_id: ProjectID
): Promise&lt;ProjectRevisionListing> {
  const datadb = await getDataDB(project_id);
  try {
    const result = await datadb.allDocs();
    const revmap: ProjectRevisionListing = {};
    for (const row of result.rows) {
      const _id: RecordID = row.key;
      revmap[_id] = await listFAIMSRecordRevisions(project_id, _id);
    }
    return revmap;
  } catch (err) {
    console.warn('failed to list data in project', project_id, err);
    throw Error('failed to list data in project');
  }
}

export async function deleteFAIMSDataForID(
  project_id: ProjectID,
  record_id: RecordID,
  userid: string
): Promise&lt;RevisionID> {
  const record = await getRecord(project_id, record_id);
  if (record.heads.length !== 1) {
    throw Error('Too many head revisions, must choose a specific head');
  }
  try {
    return await setRecordAsDeleted(
      project_id,
      record_id,
      record.heads[0],
      userid
    );
  } catch (err) {
    console.warn(
      'failed to delete data with id',
      project_id,
      record_id,
      userid,
      err
    );
    throw Error('failed to delete data with id');
  }
}

export async function undeleteFAIMSDataForID(
  project_id: ProjectID,
  record_id: RecordID,
  userid: string
): Promise&lt;RevisionID> {
  const record = await getRecord(project_id, record_id);
  if (record.heads.length !== 1) {
    throw Error('Too many head revisions, must choose a specific head');
  }
  try {
    return await setRecordAsUndeleted(
      project_id,
      record_id,
      record.heads[0],
      userid
    );
  } catch (err) {
    console.warn(
      'failed to undelete data with id',
      project_id,
      record_id,
      userid,
      err
    );
    throw Error('failed to undelete data with id');
  }
}

export async function setRecordAsDeleted(
  project_id: ProjectID,
  obsid: RecordID,
  base_revid: RevisionID,
  user: string
): Promise&lt;RevisionID> {
  const datadb = await getDataDB(project_id);
  const date = new Date();
  const base_revision = await getRevision(project_id, base_revid);
  const new_rev_id = generateFAIMSRevisionID();
  const new_revision: Revision = {
    _id: new_rev_id,
    revision_format_version: 1,
    avps: base_revision.avps,
    type: base_revision.type,
    record_id: obsid,
    parents: [base_revid],
    created: date.toISOString(),
    created_by: user,
    deleted: true,
    relationship: base_revision.relationship,
  };
  await datadb.put(new_revision);
  await updateHeads(project_id, obsid, [base_revision._id], new_rev_id);
  return new_rev_id;
}

export async function setRecordAsUndeleted(
  project_id: ProjectID,
  obsid: RecordID,
  base_revid: RevisionID,
  user: string
): Promise&lt;RevisionID> {
  const datadb = await getDataDB(project_id);
  const date = new Date();
  const base_revision = await getRevision(project_id, base_revid);
  const new_rev_id = generateFAIMSRevisionID();
  const new_revision: Revision = {
    _id: new_rev_id,
    revision_format_version: 1,
    avps: base_revision.avps,
    type: base_revision.type,
    record_id: obsid,
    parents: [base_revid],
    created: date.toISOString(),
    created_by: user,
    deleted: false,
    relationship: base_revision.relationship,
  };
  await datadb.put(new_revision);
  await updateHeads(project_id, obsid, [base_revision._id], new_rev_id);
  return new_rev_id;
}

export async function getRecordMetadata(
  project_id: ProjectID,
  record_id: RecordID,
  revision_id: RevisionID
): Promise&lt;RecordMetadata> {
  try {
    const record = await getRecord(project_id, record_id);
    const revision = await getRevision(project_id, revision_id);
    const hrid = (await getHRID(project_id, revision)) ?? record_id;
    return {
      project_id: project_id,
      record_id: record_id,
      revision_id: revision_id,
      created: new Date(record.created),
      created_by: record.created_by,
      updated: new Date(revision.created),
      updated_by: revision.created_by,
      conflicts: record.heads.length > 1,
      deleted: revision.deleted ? true : false,
      hrid: hrid,
      type: record.type,
      relationship: revision.relationship,
    };
  } catch (err) {
    console.debug(
      'failed to get record metadata:',
      project_id,
      record_id,
      revision_id
    );
    logError(err);
    throw Error(
      'failed to get record metadata: {project_id} {record_id} {revision_id}'
    );
  }
}

export async function getHRIDforRecordID(
  project_id: ProjectID,
  record_id: RecordID
): Promise&lt;string> {
  try {
    const record = await getRecord(project_id, record_id);
    const revision_id = record.heads[0];
    const revision = await getRevision(project_id, revision_id);
    const hrid = (await getHRID(project_id, revision)) ?? record_id;
    return hrid;
  } catch (err) {
    console.warn('Failed to get hrid', err);
    return record_id;
  }
}

export async function getRecordsByType(
  project_id: ProjectID,
  type: FAIMSTypeName,
  relation_type: string,
  record_id: string,
  field_id: string,
  relation_linked_vocabPair: string[] | null = null
): Promise&lt;RecordReference[]> {
  try {
    let relation_vocab: string[] | null = null;
    if (relation_type !== 'faims-core::Child') {
      relation_vocab = [
        DEFAULT_REALTION_LINK_VOCAB,
        DEFAULT_REALTION_LINK_VOCAB,
      ]; //default value of the linked items
      if (
        relation_linked_vocabPair !== null &amp;&amp;
        relation_linked_vocabPair.length > 0
      )
        relation_vocab = relation_linked_vocabPair; //get the name from relation_linked_vocabPair
    }
    const records: RecordReference[] = [];
    await listRecordMetadata(project_id).then(record_list => {
      for (const key in record_list) {
        const metadata = record_list[key];
        if (DEBUG_APP) {
          console.debug('Records', key, metadata);
        }

        let is_parent = false;
        const relationship = metadata['relationship'];

        if (relation_type === 'faims-core::Child') {
          //check if record has the parent, record should only have one parent
          if (
            relationship === undefined ||
            relationship['parent'] === undefined ||
            relationship['parent'] === null ||
            relationship['parent'].record_id === undefined
          )
            is_parent = false;
          else if (relationship['parent'].record_id !== record_id)
            is_parent = true;
          else if (
            relationship['parent'].record_id === record_id &amp;&amp;
            relationship['parent'].field_id !== field_id
          )
            is_parent = true;
        }
        console.debug(
          'relationship',
          metadata,
          relationship,
          record_id,
          field_id,
          is_parent
        );
        if (!metadata.deleted &amp;&amp; metadata.type === type &amp;&amp; !is_parent) {
          const hrid =
            metadata.hrid !== '' &amp;&amp; metadata.hrid !== undefined
              ? metadata.hrid
              : metadata.record_id;
          if (relation_vocab === null)
            records.push({
              project_id: project_id,
              record_id: metadata.record_id,
              record_label: hrid,
            });
          else
            records.push({
              project_id: project_id,
              record_id: metadata.record_id,
              record_label: hrid,
              relation_type_vocabPair: relation_vocab, // pass the value of the vocab
            });
          if (DEBUG_APP) {
            console.debug('Not deleted Records', key, metadata);
          }
        }
      }
    });
    return records;
  } catch (err) {
    // TODO: What are we doing here, why would things error?
    const records = await getAllRecordsOfType(project_id, type);
    console.warn(err);
    return records;
  }
}

async function filterRecordMetadata(
  project_id: ProjectID,
  record_list: RecordMetadata[],
  filter_deleted: boolean
): Promise&lt;RecordMetadata[]> {
  const new_record_list: RecordMetadata[] = [];
  for (const metadata of record_list) {
    if (DEBUG_APP) {
      console.debug('Records', metadata);
    }
    if (
      !(metadata.deleted &amp;&amp; filter_deleted) &amp;&amp;
      (await shouldDisplayRecord(project_id, metadata))
    ) {
      new_record_list.push(metadata);
      if (DEBUG_APP) {
        console.debug('Not deleted Records', metadata);
      }
    }
  }
  if (DEBUG_APP) {
    console.debug('Reduced record list', new_record_list);
  }
  return new_record_list;
}

function sortByLastUpdated(record_list: RecordMetadata[]): RecordMetadata[] {
  return record_list.sort((a: RecordMetadata, b: RecordMetadata) => {
    if (a &lt; b) {
      return 1;
    }
    if (a > b) {
      return -1;
    }
    return 0;
  });
}

export async function getMetadataForAllRecords(
  project_id: ProjectID,
  filter_deleted: boolean
): Promise&lt;RecordMetadata[]> {
  try {
    const record_list = Object.values(await listRecordMetadata(project_id));
    return await filterRecordMetadata(
      project_id,
      sortByLastUpdated(record_list),
      filter_deleted
    );
  } catch (error) {
    console.debug('Failed to get record metadata for', project_id);
    logError(error);
    return [];
  }
}

export async function getRecordsWithRegex(
  project_id: ProjectID,
  regex: string,
  filter_deleted: boolean
): Promise&lt;RecordMetadata[]> {
  try {
    const record_list = Object.values(
      await getAllRecordsWithRegex(project_id, regex)
    );
    return await filterRecordMetadata(project_id, record_list, filter_deleted);
  } catch (error) {
    console.debug('Failed to regex search for', project_id, regex);
    logError(error);
    return [];
  }
}
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.0</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>


</body>
</html>
