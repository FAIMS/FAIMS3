import {useEffect, useState} from 'react';
import {add_initial_listener} from '../sync/event-handler-registration';

/**
 * Given that an event has just happened from EventEmitter,
 * this fetches & translates any state data for a DBTracker to keep track of
 *
 * unknown[] args: These may not be consumed by the EventStateMapping, but these
 * are the arguments directly passed from the initializeEvents emission
 *
 * State: State that is kept track of by DBTracker
 */
export type EventStateMapping<Params extends {}, State> =
  | ((params: Params, ...event_args: any[]) => State)
  | ((params: Params, ...event_args: any[]) => Promise<State>);

/**
 * Given an event from the EventEmitter, determines what type
 * of params it has (for a given DBTracker)
 */
export type EventParamsMapping<Params extends {}> =
  | ((...event_args: any[]) => Params)
  | ((...event_args: any[]) => Promise<Params>);

export const default_filter = () => true;

type TrackPoint<P extends {}, S> = [
  string, // Event name to listen on initializeEvents
  // When an event of said name triggers, this function determines if
  // it applies to a given parameterset that's being listened for
  EventParamsMapping<P>,
  EventStateMapping<P, S>
];

type AttachedPoint = (...args: unknown[]) => void;

type FullState<S> =
  | {err: {}; state?: undefined; loading?: undefined}
  | {err?: undefined; state: S; loading?: undefined}
  | {err?: undefined; state?: undefined; loading: boolean};
type StateListener<S> = (state: FullState<S>) => void;

/**
 * Concept:
 *   An instance for every updatable state that needs to be kept track of.
 *   An updatable state is data derived from a PouchDB document or set of
 *   documents, which may change.
 *   The PouchDB emits change events, and those change events are filtered
 *   through this class, converting them to the form expected, and emits to
 *   any 'listeners'.
 *   Importantly, the PouchDB's raw data is broken up into a key-value of
 *   'Params' (key) and 'State' (value), which may be updated at separate times.
 *   _A Listener only listens for changes to state on 1 Param_
 *
 * store_all mode:
 *   Sometimes _all_ state must be kept track of, even though no one uses it
 *   yet, because some listener might come around later and need state.
 *
 *   So when store_all is set true, all state is kept whenever updates come
 *   through from the PouchDB.
 *
 * non-store_all mode:
 *   In the use case that a listener only needs to listen for updates, not to
 *   know the state, but just to keep up to date, store_all can be set to false
 *   to prevent unused memory from staying around
 *
 * Loading:
 *   When you try to get a state for a Param, there is a union (FullState<S>)
 *   that is spit out. This is also given out to listeners when updates occur.
 *
 *   Once a Promise<State> is running for a given Param, (i.e. an update event
 *   from the DB came in recently) state for that Param is {loading: true}
 *
 *   However, if no events have ever been emitted for a given Param, OR (in
 *   non-store_all mode) if they have been emitted before addListener(param) was
 *   called and, its state is in {loading:false}
 *
 * Implementation:
 *   At construction time is when the PouchDB's change events are hooked into.
 *   This is done using a 'TrackPoint' object: Just an event name, and
 *   converter functions to get the Param(s) & State(s) (key & value) that
 *   were updated in the event.
 *
 *   Each listener is stored in a list. 1 list per Param
 *
 * Example:
 *   Params: When a DBTracker is used (i.e. with useDBTracker), it is tracking
 *   a specific thing, e.g. a project, or an observation in a project, or a
 *   specific revision of an observation in a project. Params is used in said
 *   specification, e.g. [project_id], [project_id, observation_id], etc.
 */
export class DBTracker<P extends {}, S> {
  store_all = true;

  /**
   * For every unique parameters, it has a unique state. This state
   * is generated by EventStateMapping<P, S>, and is generated when
   * an event from the initializeEvents is emitted.
   *
   * A valid param not being in the map signifies that there's no StateListeners
   * for the given param. e.g. there is no reason to listen for projectA if the
   * only thing visible on the webpage is projectB, so projectB will be the
   * only param of this map.
   *
   * However if store_all is true, then not being in the map only signifies that
   * no events have been received for the param.
   */
  states: Map<P, FullState<S>> = new Map();

  /**
   * Gets the current state corresponding to a Params
   * If the params is unknown, returns {loading:false}
   * (Which is returned even if addListener(params) was called)
   *
   * @param params Parameters to get state for, e.g. {project_id}
   * @returns State of the current param. {loading: boolean} means
   *          that no updates have been received for the given param yet.
   */
  getState(params: P): FullState<S> {
    return this.states.get(params) || {loading: false};
  }

  /**
   * Instantiated at construction time of the DBTracker,
   * and when the initializeEvents calls the _attachTo function,
   *
   * Since for each track_point argument to DBTracker.constructor will run a
   * EventEmitter.on(...), said event has to be removed sometime.
   * To faciliate this removal, the second arg to EventEmitter.on is saved
   * for every TrackPoint<P, S>, in this variable.
   */
  _attachments: Map<TrackPoint<P, S>, AttachedPoint> = new Map();

  /**
   * Between when an event is emitted and the Promise<State> is resolved,
   * a State for the corresponding Parameter is in a loading state.
   *
   * This state is reflected in this.states. But also, while in this state,
   * another event may be emitted, in which case the first Promise<State>
   * MUST NOT be allowed to resolve. To disallow this, this _load_interrupts
   * increments whenever a Promise is about to be listened for.
   *
   * See _promisedState
   */
  _load_interrupts: Map<P, number> = new Map();

  /**
   * Similarly to _load_interrupts, between when an event is emitted and the
   * Promise<Params> is resolved, this whole DBTracker is in a loading state
   *
   * This state is not reflected anywhere except to the extent that a Promise
   * is running. But while in this state, another event may be emitted, in which
   * case the first Promise<Params> MUST WAIT for the second Promise<Params> to
   * resolve. If they both resolve to the same Params, only one Promise<State>
   * is fetched. (If they're different, they won't interefere, so it's fine)
   *
   * This is to prevent an event occuring, then another event of the same Params
   * as the first to occur and go through all code before the first event has a
   * chance to set _load_interrupts.
   *
   * See _promisedParams
   */
  _params_interrupt = 1;

  /**
   * While a Promise<Params> is resolving, this accumulates the list of all
   * Promise<Params> that resolved but were interrupted by another one resolving
   */
  _params_resolved = new Map<P, (resolved: P) => void>();

  /*
   * Each of these _X_listeners maps stores a list of callables to be run
   * when the State corresponding to the given Param P changes.
   * This might be the state starting to load another state (unload_listeners)
   * or it might be an error/resolve
   */

  _listeners: Map<P, StateListener<S>[]> = new Map();

  /**
   * Main publically used function: To listen for changes to a DB's object
   * The DB object is parameterized by P, so the specific object to listen to
   * is given as params.
   *
   * If this DBTracker is not store_all, then an addListener call is required
   * for each param's state you wish to keep track of
   *
   * @param params Parameter to filter updates by
   * @param listener Listener to execute when the state
   *                 of this.state.get(params) is changed.
   */
  addListener(params: P, listener: StateListener<S>): void {
    const listeners_for_params = this._listeners.get(params);
    if (listeners_for_params !== undefined) {
      listeners_for_params.push(listener);
    } else {
      this._listeners.set(params, [listener]);
    }

    if (!this.states.has(params)) {
      // First encounter with the given params, must updates to be "loading"
      this._setState(params, {loading: false}, true);
    }
  }
  /**
   * Remove listeners that were added by addListener
   * State for a given param will stick around until all its listeners are removed
   * So this serves to allow GC'ing of state if store_all is false
   *
   * @param listeners Any one of state_listeners, unload_listeners, error_listeners
   * @param params (Expose publically) Parameter that updates were filtered by
   * @param listener (Expose publically) Listener that was executed when the state
   *                 of this.state.get(params) is changed.
   */
  removeListener(params: P, listener: StateListener<S>): void {
    const listeners_for_params = this._listeners.get(params);
    if (listeners_for_params !== undefined) {
      if (listeners_for_params === [listener]) {
        // This was the last listener left for said parameter
        this._listeners.delete(params);
        this._try_cleanup_unlistened(params);
      } else {
        const idx = listeners_for_params.indexOf(listener);
        if (idx >= 0) {
          // Listener found, delete 1 element
          listeners_for_params?.splice(idx, 1);
        }
      }
    }
  }

  _try_cleanup_unlistened(params: P): void {
    // When all listeners for a given Params removed,
    // we can remove the state as well
    if (!this.store_all && !this._listeners.has(params)) {
      this.states.delete(params);
    }
  }

  constructor(...track_points: TrackPoint<P, S>[]) {
    add_initial_listener(this._attachTo.bind(this, track_points));
  }

  _globalError(error: {}) {
    //TODO
  }

  /**
   * Sets/Updates the state for a given Param that is being listened for
   * (or if store_all is true, sets/updates the state)
   *
   * If this isn't in store_all mode, and the Param is not yet listening,
   * nothing will be done in this function.
   *
   * Errors are propagated to this._globalError
   *
   * @param params Param to update the corresponding state for
   * @param state State to set param to, NOT LOADING, either error or valid.
   */
  _setState(params: P, state: FullState<S>, store_new = false) {
    if (this.states.has(params) || this.store_all || store_new) {
      this.states.set(params, state);

      // Run state listeners
      const listeners = this._listeners.get(params);
      if (listeners !== undefined) {
        for (const listener of listeners) {
          try {
            listener(state);
          } catch (error) {
            this._globalError(error);
            break;
          }
        }
      }
    }
  }

  /**
   * When a Params is about to become available (we may be waiting for PouchDB,
   * or waiting for an EventStateMapping to resolve) this is called with the
   * promise to get the Params
   *
   * If the promise resolves, the callback is called
   *
   * If something else calls _promisedParams before unresolved resolves, this will
   * wait both unresolved's to resolve before any callback is run
   *
   * If something else calls _promisedParams before unresolved resolves, AND
   * said something resolves to the same thing that this unresolved resolves to,
   * ONLY the callback for the latest resolution is called.
   *
   * @param unresolved Promise that will resolve to a Param value
   * @param callback When it is know that no other _promisedParams with
   *                 the same Param value is going to be, or has resolved,
   *                 this is called. It is usually _promisedState bound to
   *                 some state resolution from a track point in _attachTo
   *                 This is expected to do its own error handling
   */
  _promisedParams(unresolved: Promise<P>, callback: (resolved: P) => void) {
    const my_load = this._params_interrupt + 1;
    this._params_interrupt = my_load;

    unresolved.then((params: P) => {
      // A _promisedParams may currently still be resolving
      // while this .then has executed.
      this._params_resolved.set(params, callback);

      if (this._params_interrupt === my_load) {
        // No other Promise<Param>s to wait for, execute all the latest
        // callbacks for each unique Param:
        this._params_resolved.forEach((cb, param) => cb(param));
        this._params_resolved.clear();
      }
    }, this._globalError);
  }

  /**
   * When a State is about to become available (we may be waiting for PouchDB,
   * or waiting for an EventStateMapping to resolve) this is called with the
   * Promise to get the state.
   *
   * If the Promise resolves, this DBTracker updates the state for the given
   * param, and notifies anything listening for updates on the given param.
   *
   * If something else calles _promisedState before the first Promise resolves,
   * the first Promise's result and ERRORS are completley IGNORED.
   *
   * _resolveState or _errorState will be called after the Promise resolves,
   * which go on to call the state_listeners or error_listeners
   *
   * @param params Param that is about to have its state updated
   * @param state Promise resolving into state, or error
   */
  _promisedState(params: P, state: Promise<S>) {
    const existing_state = this.states.get(params);
    if (!this.store_all && existing_state === undefined) {
      // Not storing any unlistened states:
      return;
    }

    // Like _rejectState, _resolveState, the this.states must be updated
    // as to not expose old state
    this._setState(params, {loading: true});

    // INTERRUPTION

    // To be able to interrupt something, the _load_interrupts is incremented
    const my_load = (this._load_interrupts.get(params) || 0) + 1;

    // Update to reflect my_load:
    this._load_interrupts.set(params, my_load);

    // To detect interruption, my_load is compared with this._load_interrupts.get(params)
    // When the state promise resolves/rejects
    const is_uninterrupted = () =>
      my_load === this._load_interrupts.get(params);

    // LISTENING

    state.then(
      (state: S) => {
        if (is_uninterrupted()) {
          this._setState(params, {state: state});
        }
      },
      (err: {}) => {
        if (is_uninterrupted()) {
          this._setState(params, {err: err});
        }
      }
    );
  }

  /**
   * Called once the EventEmitter is created, this attaches the events for this
   * DBTracker to the EventEmitter. Events are only attached once, when this is called
   *
   * @param track_points The events and their corresponding conversions to param/state
   *                     that are to be registered on the event emitter to listen on.
   * @param emitter EventEmitter ot listen for updates on.
   */
  _attachTo(track_points: TrackPoint<P, S>[], emitter: EventEmitter): void {
    // For each 'event' to attach to:
    for (const tpoint of track_points) {
      // The listener:
      const attach_point = (...args: unknown[]) => {
        // _promisedParams takes a Promise, but tpoint[1] might be a non-promise
        // so resolve directly:
        const wait_params = Promise.resolve(tpoint[1](...args));
        this._promisedParams(wait_params, this_params => {
          try {
            // And now we again wait for a Promise to resolve, but this time
            // it's the per-Param state that must resolve
            const wait_state = Promise.resolve(tpoint[2](this_params, ...args));
            this._promisedState(this_params, wait_state);
          } catch (err) {
            this._rejectState(this_params, err);
          }
        });
      };

      // Store it for later deletion
      if (this._attachments.has(tpoint)) {
        throw Error('DBTracker _attachTo called twice');
      }
      this._attachments.set(tpoint, attach_point);

      // Listen to event and trigger the listener
      emitter.on(tpoint[0], attach_point);
    }
  }
}

export function useDBTracker<P extends {}, S>(
  tracker: DBTracker<P, S>,
  params: P
): FullState<S> {
  const [reactState, setReactState] = useState(tracker.getState(params));
  useEffect(() => {
    tracker.addListener(params, setReactState);
    return tracker.removeListener.bind(tracker, params, setReactState);
  }, [params]);

  return reactState;
}
