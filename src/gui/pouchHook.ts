import {useEffect, useState} from 'react';
import {add_initial_listener} from '../sync/event-handler-registration';

/**
 * Given that an event has just happened from EventEmitter,
 * this fetches & translates any state data for a DBTracker to keep track of
 *
 * unknown[] args: These may not be consumed by the EventStateMapping, but these
 * are the arguments directly passed from the initializeEvents emission
 *
 * State: State that is kept track of by DBTracker
 */
export type EventStateMapping<Params extends {}, State> = (
  params: Params,
  ...event_args: any[]
) => Promise<State>;

/**
 * Given an event from the EventEmitter, determines what type
 * of params it has (for a given DBTracker)
 */
export type EventParamsMapping<Params extends {}> = (
  ...event_args: any[]
) => Params;

export const default_filter = () => true;

type TrackPoint<P extends {}, S> = [
  string, // Event name to listen on initializeEvents
  // When an event of said name triggers, this function determines if
  // it applies to a given parameterset that's being listened for
  EventParamsMapping<P>,
  EventStateMapping<P, S>
];

type AttachedPoint = (...args: unknown[]) => void;

type FullState<S> =
  | {err: {}; state: undefined; initial: undefined}
  | {err: undefined; state: S; initial: undefined}
  | {err: undefined; state: undefined; initial: boolean};
type StateListener<S> = (state: FullState<S>) => void;

/**
 * Params: When a DBTracker is used (i.e. with useDBTracker), it is tracking
 * a specific thing, e.g. a project, or an observation in a project, or a
 * specific revision of an observation in a project. Params is used in said
 * specification, e.g. [project_id], [project_id, observation_id], etc.
 */
export class DBTracker<P extends {}, S> {
  store_all = true;

  /**
   * For every unique parameters, it has a unique state. This state
   * is generated by EventStateMapping<P, S>, and is generated when
   * an event from the initializeEvents is emitted.
   *
   * nulls as values signify that the event filling this state hasn't
   * been emitted yet, but it is expected to emit/error at some point
   *
   * A valid param not being in the map signifies that there's no StateListeners
   * for the given param. e.g. there is no reason to listen for projectA if the
   * only thing visible on the webpage is projectB, so projectB will be the
   * only param of this map.
   */
  states: Map<P, FullState<S>> = new Map();

  /**
   * Gets the current state corresponding to a Params
   * @param params Parameters to get state for, e.g. {project_id}
   * @returns State of the current param. {initial: boolean} means
   *          that no updates have been received for the given param yet.
   */
  getState(params: P): FullState<S> {
    return (
      this.states.get(params) || {
        err: undefined,
        state: undefined,
        initial: true,
      }
    );
  }

  /**
   * Instantiated at construction time of the DBTracker,
   * and when the initializeEvents calls the _attachTo function,
   *
   * Since for each track_point argument to DBTracker.constructor will run a
   * EventEmitter.on(...), said event has to be removed sometime.
   * To faciliate this removal, the second arg to EventEmitter.on is saved
   * for every TrackPoint<P, S>, in this variable.
   */
  _attachments: Map<TrackPoint<P, S>, AttachedPoint> = new Map();

  /**
   * Between when an event is emitted and the Promise<State> is resolved,
   * a State for the corresponding Parameter is in a loading state.
   *
   * This state is reflected in this.states. But also, while in this state,
   * another event may be emitted, in which case the first Promise<State>
   * MUST NOT be allowed to resolve. To disallow this, this _load_interrupts
   * increments whenever a Promise is about to be listened for.
   *
   * See _promisedState
   */
  _load_interrupts: Map<P, number> = new Map();

  /*
   * Each of these _X_listeners maps stores a list of callables to be run
   * when the State corresponding to the given Param P changes.
   * This might be the state starting to load another state (unload_listeners)
   * or it might be an error/resolve
   */

  _listeners: Map<P, StateListener<S>[]> = new Map();

  /**
   * Main publically used function: To listen for changes to a DB's object
   * The DB object is parameterized by P, so the specific object to listen to
   * is given as params.
   *
   * If this DBTracker is not store_all, then an addListener call is required
   * for each param's state you wish to keep track of
   *
   * @param params Parameter to filter updates by
   * @param listener Listener to execute when the state
   *                 of this.state.get(params) is changed.
   */
  addListener(params: P, listener: StateListener<S>): void {
    const listeners_for_params = this._listeners.get(params);
    if (listeners_for_params !== undefined) {
      listeners_for_params.push(listener);
    } else {
      this._listeners.set(params, [listener]);
    }

    if (!this.states.has(params)) {
      this.states.set(params, {
        err: undefined,
        state: undefined,
        initial: true,
      });
    }
  }
  /**
   * Remove listeners that were added by addListener
   * State for a given param will stick around until all its listeners are removed
   * So this serves to allow GC'ing of state if store_all is false
   *
   * @param params Parameter that updates were filtered by
   * @param listener Listener that was added by addListener, now to be removed
   */
  removeListener(params: P, listener: StateListener<S>): void {
    const listeners_for_params = this._listeners.get(params);
    if (listeners_for_params !== undefined) {
      if (listeners_for_params === [listener]) {
        // This was the last listener left for said parameter
        this._listeners.delete(params);
        this._try_cleanup_unlistened(params);
      } else {
        const idx = listeners_for_params.indexOf(listener);
        if (idx >= 0) {
          // Listener found, delete 1 element
          listeners_for_params?.splice(idx, 1);
        }
      }
    }
  }

  _try_cleanup_unlistened(params: P): void {
    // When all listeners for a given Params removed,
    // we can remove the state as well
    if (!this.store_all && !this._listeners.has(params)) {
      this.states.delete(params);
    }
  }

  constructor(...track_points: TrackPoint<P, S>[]) {
    add_initial_listener(this._attachTo.bind(this, track_points));
  }

  _resolveState(params: P, state: S) {
    if (this.states.has(params) || this.store_all) {
      this.states.set(params, {
        err: undefined,
        state: state,
        initial: undefined,
      });
    }
  }

  _rejectState(params: P, error: {}) {
    if (this.states.has(params) || this.store_all) {
      this.states.set(params, {
        err: error,
        state: undefined,
        initial: undefined,
      });
    }
  }

  /**
   * When a State is about to become available (we may be waiting for PouchDB,
   * or waiting for an EventStateMapping to resolve) this is called with the
   * Promise to get the state.
   *
   * If the Promise resolves, this DBTracker updates the state for the given
   * param, and notifies anything listening for updates on the given param.
   *
   * If something else calles _promisedState before the first Promise resolves,
   * the first Promise's result and ERRORS are completley IGNORED.
   *
   * _resolveState or _errorState will be called after the Promise resolves,
   * which go on to call the state_listeners or error_listeners
   *
   * @param params Param that is about to have its state updated
   * @param state Promise resolving into state, or error
   */
  _promisedState(params: P, state: Promise<S>) {
    const existing_state = this.states.get(params);
    if (!this.store_all && existing_state === undefined) {
      // Not storing any unlistened states:
      return;
    }

    // Like _rejectState, _resolveState, the this.states must be updated
    // as to not expose old state
    this.states.set(params, {
      err: undefined,
      state: undefined,
      initial: false,
    });

    // INTERRUPTION

    // To be able to interrupt something, the _load_interrupts is incremented
    const my_load = (this._load_interrupts.get(params) || 0) + 1;

    // Update to reflect my_load:
    this._load_interrupts.set(params, my_load);

    // To detect interruption, my_load is compared with this._load_interrupts.get(params)
    // When the state promise resolves/rejects
    const is_uninterrupted = () =>
      my_load === this._load_interrupts.get(params);

    // LISTENING

    state.then(
      (state: S) => {
        if (is_uninterrupted()) {
          this._resolveState(params, state);
        }
      },
      (err: {}) => {
        if (is_uninterrupted()) {
          this._rejectState(params, err);
        }
      }
    );
  }

  /**
   * Called once the EventEmitter is created, this attaches the events for this
   * DBTracker to the EventEmitter. Events are only attached once, when this is called
   *
   * @param track_points The events and their corresponding conversions to param/state
   *                     that are to be registered on the event emitter to listen on.
   * @param emitter EventEmitter ot listen for updates on.
   */
  _attachTo(track_points: TrackPoint<P, S>[], emitter: EventEmitter): void {
    // For each 'event' to attach to:
    for (const tpoint of track_points) {
      const attach_point = (...args: unknown[]) => {
        // The listener:
        const this_params = tpoint[1](...args);
        this._promisedState(this_params, tpoint[2](this_params, ...args));
      };

      // Store it for later deletion
      if (this._attachments.has(tpoint)) {
        throw Error('DBTracker _attachTo called twice');
      }
      this._attachments.set(tpoint, attach_point);

      // Listen to event and trigger the listener
      emitter.on(tpoint[0], attach_point);
    }
  }
}

export function useDBTracker<P extends {}, S>(
  tracker: DBTracker<P, S>,
  params: P
): FullState<S> {
  const [reactState, setReactState] = useState(tracker.getState(params));
  useEffect(() => {
    tracker.addListener(params, setReactState);
    return tracker.removeListener.bind(tracker, params, setReactState);
  }, [params]);

  return reactState;
}
